# coding: utf-8

"""
    ibl-data-manager

    API for iblai

    The version of the OpenAPI document: 2.3.38-ai-plus
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from iblai.models.api_token_cost import APITokenCost
from iblai.models.credential import Credential
from iblai.models.credential_request import CredentialRequest
from iblai.models.iblai_platform_meta import IBLAIPlatformMeta
from iblai.models.iblai_platform_meta_request import IBLAIPlatformMetaRequest
from iblai.models.iblai_platform_meta_update_request import IBLAIPlatformMetaUpdateRequest
from iblai.models.integration_credential import IntegrationCredential
from iblai.models.main_creds import MainCreds
from iblai.models.patched_credential_request import PatchedCredentialRequest
from iblai.models.use_main_creds import UseMainCreds

from iblai.api_client import ApiClient, RequestSerialized
from iblai.api_response import ApiResponse
from iblai.rest import RESTResponseType


class AiAccountApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def ai_account_orgs_credential_create(
        self,
        org: StrictStr,
        credential_request: CredentialRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_credential_create

        This is for creating llm credentials for a tenant.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.  Returns:      400: When the data is not valid, when the name already exists for the same tenant.      400: When the name already exists for the same tenant.      400: When the name already exists for the same tenant.      201 : Llm credential details.  Example :      POST : /api/ai-account/orgs/main/credential/ .      Request:       {                         \"name\": \"openai\",                         \"value\": {                             \"key\": \"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"                         },                         \"platform\": \"main\"                     }       Response:       {                         \"name\": \"openai\",                         \"value\": {                             \"key\": \"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"                         },                         \"platform\": \"main\"                     }

        :param org: (required)
        :type org: str
        :param credential_request: (required)
        :type credential_request: CredentialRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_credential_create_serialize(
            org=org,
            credential_request=credential_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Credential",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_credential_create_serialize(
        self,
        org,
        credential_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if credential_request is not None:
            _body_params = credential_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/ai-account/orgs/{org}/credential/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_credential_partial_update(
        self,
        org: StrictStr,
        patched_credential_request: Optional[PatchedCredentialRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_credential_partial_update

        This is for updating llm credentials for a tenant.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.      NotFound: When the name passed is not found.  Returns:      400: When the data is not valid, when the name already exists for the same tenant.      400: When the name already exists for the same tenant.      400: When the name already exists for the same tenant.      200 : Llm credential details.  Example :      POST : /api/ai-account/orgs/main/credential/ .      Request:       {                         \"name\": \"openai\",                         \"value\": {                             \"key\": \"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"                         },                         \"platform\": \"main\"                     }       Response:       {                         \"name\": \"openai\",                         \"value\": {                             \"key\": \"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"                         },                         \"platform\": \"main\"                     }

        :param org: (required)
        :type org: str
        :param patched_credential_request:
        :type patched_credential_request: PatchedCredentialRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_credential_partial_update_serialize(
            org=org,
            patched_credential_request=patched_credential_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Credential",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_credential_partial_update_serialize(
        self,
        org,
        patched_credential_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_credential_request is not None:
            _body_params = patched_credential_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/ai-account/orgs/{org}/credential/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_credential_retrieve(
        self,
        org: StrictStr,
        name: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="Name of the credential provider")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_credential_retrieve

        This is for getting list of llm credentials for a tenant.  You can also filter the llm credentials by passing a query parameter name=<llm_name>.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.      NotFound: When the llm name passed in the paramter is not found.   Returns:      400: When the data is not valid.      200 : List of llm credentials.  Example :      GET : /api/ai-account/orgs/main/credential/ .      Response:       [                         {                             \"name\": \"openai\",                             \"value\": {                                 \"key\": \"sk-xxxxxxxxxxxxxxxxxxxxx\"                             },                             \"platform\": \"main\"                         },                         {                             \"name\": \"google\",                             \"value\": {                                 \"type\": \"service_account\",                                 \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                                 \"client_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\",                                 \"token_uri\": \"https://oauth2.googleapis.com/token\",                                 \"project_id\": \"xxxxxxxxxxxxxx\",                                 \"private_key\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                                 \"client_email\": \"xxx-xxx-sa@xx-xxxx.iam.gserviceaccount.com\",                                 \"private_key_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                                 \"universe_domain\": \"googleapis.com\",                                 \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/xxxxxxxx.com\",                                 \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                             },                             \"platform\": \"main\"                         }                     ]

        :param org: (required)
        :type org: str
        :param name: Name of the credential provider
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_credential_retrieve_serialize(
            org=org,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Credential",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_credential_retrieve_serialize(
        self,
        org,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ai-account/orgs/{org}/credential/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_integration_credential_create(
        self,
        org: StrictStr,
        credential_request: CredentialRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_integration_credential_create

        This is for creating integration credentials for a tenant.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.  Returns:      400: When the data is not valid, when the name already exists for the same tenant.      400: When the name already exists for the same tenant.      201 : Tntegration credential details.  Example :      POST : /api/ai-account/orgs/main/integration-credential/ .      Request:       {                         \"name\": \"google-drive\",                         \"value\": {                             \"type\": \"service_account\",                             \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                             \"client_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"token_uri\": \"https://oauth2.googleapis.com/token\",                             \"project_id\": \"xxxxxxxxxxxxxx\",                             \"private_key\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"client_email\": \"xxx-xxx-sa@xx-xxxx.iam.gserviceaccount.com\",                             \"private_key_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"universe_domain\": \"googleapis.com\",                             \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/xxxxxxxx.com\",                             \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                         },                         \"platform\": \"main\"                     }       Response:       {                         \"name\": \"google-drive\",                         \"value\": {                             \"type\": \"service_account\",                             \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                             \"client_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"token_uri\": \"https://oauth2.googleapis.com/token\",                             \"project_id\": \"xxxxxxxxxxxxxx\",                             \"private_key\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"client_email\": \"xxx-xxx-sa@xx-xxxx.iam.gserviceaccount.com\",                             \"private_key_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"universe_domain\": \"googleapis.com\",                             \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/xxxxxxxx.com\",                             \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                         },                         \"platform\": \"main\"                     }

        :param org: (required)
        :type org: str
        :param credential_request: (required)
        :type credential_request: CredentialRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_integration_credential_create_serialize(
            org=org,
            credential_request=credential_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IntegrationCredential",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_integration_credential_create_serialize(
        self,
        org,
        credential_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if credential_request is not None:
            _body_params = credential_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/ai-account/orgs/{org}/integration-credential/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_integration_credential_partial_update(
        self,
        org: StrictStr,
        patched_credential_request: Optional[PatchedCredentialRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_integration_credential_partial_update

        This is for updating Integration credentials for a tenant.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.      NotFound: When the name passed is not found.  Returns:      400: When the data is not valid, when the name already exists for the same tenant.      400: When the name already exists for the same tenant.      200 : Llm redential details.  Example :      POST : /api/ai-account/orgs/main/integration-credential/ .      Request:       {                         \"name\": \"google-drive\",                         \"value\": {                             \"type\": \"service_account\",                             \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                             \"client_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"token_uri\": \"https://oauth2.googleapis.com/token\",                             \"project_id\": \"xxxxxxxxxxxxxx\",                             \"private_key\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"client_email\": \"xxx-xxx-sa@xx-xxxx.iam.gserviceaccount.com\",                             \"private_key_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"universe_domain\": \"googleapis.com\",                             \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/xxxxxxxx.com\",                             \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                         },                         \"platform\": \"main\"                     }       Response:       {                         \"name\": \"google-drive\",                         \"value\": {                             \"type\": \"service_account\",                             \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                             \"client_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"token_uri\": \"https://oauth2.googleapis.com/token\",                             \"project_id\": \"xxxxxxxxxxxxxx\",                             \"private_key\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"client_email\": \"xxx-xxx-sa@xx-xxxx.iam.gserviceaccount.com\",                             \"private_key_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                             \"universe_domain\": \"googleapis.com\",                             \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/xxxxxxxx.com\",                             \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                         }                         \"platform\": \"main\"                     }

        :param org: (required)
        :type org: str
        :param patched_credential_request:
        :type patched_credential_request: PatchedCredentialRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_integration_credential_partial_update_serialize(
            org=org,
            patched_credential_request=patched_credential_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IntegrationCredential",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_integration_credential_partial_update_serialize(
        self,
        org,
        patched_credential_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_credential_request is not None:
            _body_params = patched_credential_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/ai-account/orgs/{org}/integration-credential/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_integration_credential_retrieve(
        self,
        org: StrictStr,
        name: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="Name of the credential provider")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_integration_credential_retrieve

        This is for getting  a list of integration credentials for a tenant.  You can also filter the integration credentials by passing a query parameter name=<llm_name>.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.      NotFound: When the  name passed in the paramter is not found.   Returns:      400: When the data is not valid.      200 : List of integration credentials.  Example :      GET : /api/ai-account/orgs/main/integration-credential/ .      Response:       [                         {                             \"name\": \"google-drive\",                             \"value\": {                                 \"type\": \"service_account\",                                 \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                                 \"client_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxx\",                                 \"token_uri\": \"https://oauth2.googleapis.com/token\",                                 \"project_id\": \"xxxxxxxxxxxxxx\",                                 \"private_key\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                                 \"client_email\": \"xxx-xxx-sa@xx-xxxx.iam.gserviceaccount.com\",                                 \"private_key_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",                                 \"universe_domain\": \"googleapis.com\",                                 \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/xxxxxxxx.com\",                                 \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                             },                             \"platform\": \"main\"                         }                     ]

        :param org: (required)
        :type org: str
        :param name: Name of the credential provider
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_integration_credential_retrieve_serialize(
            org=org,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IntegrationCredential",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_integration_credential_retrieve_serialize(
        self,
        org,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ai-account/orgs/{org}/integration-credential/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_platform_metadata_create(
        self,
        org: StrictStr,
        iblai_platform_meta_request: IBLAIPlatformMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_platform_metadata_create

        This is for  adding platform metadata. In order to use google as your LLM provider, you need to specify `google_project` (your google cloud project id) and `google_location`, which defaults to `us-central1`  Accessible to tenant admins only.  Raises:      NotFound: When platfom metadata is not found.  Returns:      201 : Platform metadata details.  Example :      GET : /api/ai-account/orgs/main/platform-metadata/ .      Request:        {                         \"data\": {                             \"llms\": {                                 \"google\": {                                     \"credential\": {                                         \"type\": \"service_account\",                                         \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                                         \"client_id\": \"\",                                         \"token_uri\": \"https://oauth2.googleapis.com/token\",                                         \"project_id\": \"NO PROJECT ID IS PROVIDED\",                                         \"private_key\": \"\",                                         \"client_email\": \"\",                                         \"private_key_id\": \"\",                                         \"universe_domain\": \"googleapis.com\",                                         \"client_x509_cert_url\": \"\",                                         \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",                                     },                                     \"llm_options\": {\"temperature\": 0.7},                                 },                                 \"openai\": {                                     \"credential\": {\"key\": \"NO KEY IS PROVIDED\"},                                     \"llm_options\": {\"temperature\": 0.7},                                 },                             },                         },                     }      Response:       {                         \"metadata\": {                             \"llms\": {                                 \"google\": {                                     \"credential\": {                                         \"type\": \"service_account\",                                         \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                                         \"client_id\": \"\",                                         \"token_uri\": \"https://oauth2.googleapis.com/token\",                                         \"project_id\": \"NO PROJECT ID IS PROVIDED\",                                         \"private_key\": \"\",                                         \"client_email\": \"\",                                         \"private_key_id\": \"\",                                         \"universe_domain\": \"googleapis.com\",                                         \"client_x509_cert_url\": \"\",                                         \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",                                     },                                     \"llm_options\": {\"temperature\": 0.7},                                 },                                 \"openai\": {                                     \"credential\": {\"key\": \"NO KEY IS PROVIDED\"},                                     \"llm_options\": {\"temperature\": 0.7},                                 },                             },                             \"active_llm\": \"openai\",                         }                     }

        :param org: (required)
        :type org: str
        :param iblai_platform_meta_request: (required)
        :type iblai_platform_meta_request: IBLAIPlatformMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_platform_metadata_create_serialize(
            org=org,
            iblai_platform_meta_request=iblai_platform_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "IBLAIPlatformMeta",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_platform_metadata_create_serialize(
        self,
        org,
        iblai_platform_meta_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if iblai_platform_meta_request is not None:
            _body_params = iblai_platform_meta_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/ai-account/orgs/{org}/platform-metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_platform_metadata_list(
        self,
        org: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_platform_metadata_list

        This is for getting platform metadata.  Accessible to tenant admins only.  Raises:      NotFound: When platfom metadata is not found.  Returns:      200 : Platform metadata details.  Example :      GET : /api/ai-account/orgs/main/platform-metadata/ .      Response:       {                         \"metadata\": {                             \"services\": {                                 \"google\": {                                     \"credential\": {                                         \"type\": \"service_account\",                                         \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                                         \"client_id\": \"\",                                         \"token_uri\": \"https://oauth2.googleapis.com/token\",                                         \"project_id\": \"NO PROJECT ID IS PROVIDED\",                                         \"private_key\": \"\",                                         \"client_email\": \"\",                                         \"private_key_id\": \"\",                                         \"universe_domain\": \"googleapis.com\",                                         \"client_x509_cert_url\": \"\",                                         \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                                     },                                     \"llm_options\": {                                         \"temperature\": 0.7                                     }                                 },                                 \"openai\": {                                     \"credential\": {                                         \"key\": \"NO KEY IS PROVIDED\"                                     },                                     \"llm_options\": {                                         \"temperature\": 0.7                                     }                                 }                             },                             \"active_llm\": \"openai\",                             \"active_stt\": \"google\",                             \"active_tts\": \"google\"                         }                     }

        :param org: (required)
        :type org: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_platform_metadata_list_serialize(
            org=org,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IBLAIPlatformMeta]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_platform_metadata_list_serialize(
        self,
        org,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ai-account/orgs/{org}/platform-metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_platform_metadata_update(
        self,
        org: StrictStr,
        iblai_platform_meta_update_request: Optional[IBLAIPlatformMetaUpdateRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_platform_metadata_update

        This is for  updating platform metadata.  Accessible to tenant admins only.  Raises:      NotFound: When platfom metadata is not found.  Returns:      200 : Platform metadata details.  Example :      GET : /api/ai-account/orgs/main/platform-metadata/ .      Request:        {                         \"active_llm\": \"openai\",                         \"llms\": [\"google\", \"openai\"]                     }      Response:       {                         \"metadata\": {                             \"services\": {                                 \"google\": {                                     \"credential\": {                                         \"type\": \"service_account\",                                         \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",                                         \"client_id\": \"\",                                         \"token_uri\": \"https://oauth2.googleapis.com/token\",                                         \"project_id\": \"NO PROJECT ID IS PROVIDED\",                                         \"private_key\": \"\",                                         \"client_email\": \"\",                                         \"private_key_id\": \"\",                                         \"universe_domain\": \"googleapis.com\",                                         \"client_x509_cert_url\": \"\",                                         \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\"                                     },                                     \"llm_options\": {                                         \"temperature\": 0.7                                     }                                 },                                 \"openai\": {                                     \"credential\": {                                         \"key\": \"NO KEY IS PROVIDED\"                                     },                                     \"llm_options\": {                                         \"temperature\": 0.7                                     }                                 }                             },                             \"active_llm\": \"openai\",                             \"active_stt\": \"google\",                             \"active_tts\": \"google\"                         }                     }

        :param org: (required)
        :type org: str
        :param iblai_platform_meta_update_request:
        :type iblai_platform_meta_update_request: IBLAIPlatformMetaUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_platform_metadata_update_serialize(
            org=org,
            iblai_platform_meta_update_request=iblai_platform_meta_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IBLAIPlatformMeta]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_platform_metadata_update_serialize(
        self,
        org,
        iblai_platform_meta_update_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if iblai_platform_meta_update_request is not None:
            _body_params = iblai_platform_meta_update_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/ai-account/orgs/{org}/platform-metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_tokens_list(
        self,
        org: StrictStr,
        session_id: Annotated[Optional[StrictStr], Field(description="session id of the user's chat")] = None,
        username: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="Username of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_tokens_list

        This is for getting weekly tokens.  You can also filter the list  by passing a query parameter username=<username> and session_id=<session_id>.  Accessible to tenant admins only.  Raises:      NotFound: When organization is not found.      NotFound: When session id is not found.   Returns:      400: When the data is not valid.      200 : List of tokens.  Example :      GET : /api/ai-account/orgs/main/tokens/ .      Response:       [                         {                             \"date\": \"2024-02-05\",                             \"completion_tokens\": 2147483647,                             \"prompt_tokens\": 123456785                         }                     ]

        :param org: (required)
        :type org: str
        :param session_id: session id of the user's chat
        :type session_id: str
        :param username: Username of the user
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_tokens_list_serialize(
            org=org,
            session_id=session_id,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[APITokenCost]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_tokens_list_serialize(
        self,
        org,
        session_id,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        if session_id is not None:
            
            _query_params.append(('session_id', session_id))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ai-account/orgs/{org}/tokens/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_use_default_llm_key_create(
        self,
        org: StrictStr,
        use_main_creds: UseMainCreds,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_use_default_llm_key_create

        Endpoint to enable or disable the usage of the tenant llm key  Accessible to tenant admins only.  Returns:      200: No response data.      400: When data is not valid.  Example:          POST: /api/ai-mentor/orgs/main/use-main-llm-key/          Response:      {                         \"message\": \"Tenant is now using the main credentials\"                         }

        :param org: (required)
        :type org: str
        :param use_main_creds: (required)
        :type use_main_creds: UseMainCreds
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_use_default_llm_key_create_serialize(
            org=org,
            use_main_creds=use_main_creds,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UseMainCreds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_use_default_llm_key_create_serialize(
        self,
        org,
        use_main_creds,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if use_main_creds is not None:
            _body_params = use_main_creds


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/ai-account/orgs/{org}/use-default-llm-key/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_use_free_trial_create(
        self,
        org: StrictStr,
        use_main_creds: UseMainCreds,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_use_free_trial_create

        Endpoint to enable or disable free trial for a tenant.  Accessible to tenant admins only.  Returns:      200: No response data.      400: When data is not valid.  Example:          POST: /api/ai-mentor/orgs/main/use-main-llm-key/          Request: {                     \"enable\": true                     \"disable\": false                     \"metadata\": {                         \"key\": \"value\"                     }         }          Response:      {                         \"message\": \"Tenant is now using the main credentials\"                         }

        :param org: (required)
        :type org: str
        :param use_main_creds: (required)
        :type use_main_creds: UseMainCreds
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_use_free_trial_create_serialize(
            org=org,
            use_main_creds=use_main_creds,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UseMainCreds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_use_free_trial_create_serialize(
        self,
        org,
        use_main_creds,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if use_main_creds is not None:
            _body_params = use_main_creds


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded', 
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/ai-account/orgs/{org}/use-free-trial/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_users_default_llm_key_usage_retrieve(
        self,
        org: StrictStr,
        user_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_users_default_llm_key_usage_retrieve

        Endpoint to enable or disable the usage of the tenant llm key  Accessible to tenant admins only.  Returns:      200: No response data.      400: When data is not valid.  Example:          POST: /api/ai-mentor/orgs/main/use-main-llm-key/          Response:    {                         \"use_main_credentials\": true                     }

        :param org: (required)
        :type org: str
        :param user_id: (required)
        :type user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_users_default_llm_key_usage_retrieve_serialize(
            org=org,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MainCreds",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_users_default_llm_key_usage_retrieve_serialize(
        self,
        org,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        if user_id is not None:
            _path_params['user_id'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ai-account/orgs/{org}/users/{user_id}/default-llm-key-usage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ai_account_orgs_users_free_trial_list(
        self,
        org: StrictStr,
        user_id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ai_account_orgs_users_free_trial_list

        This is for getting list of free trial status for a tenant.  Accessible to tenant admins only.  Raises:      NotFound: When tenant key is not found.      NotFound: When the name passed in the paramter is not found.   Returns:      400: When the data is not valid.      200 : List of free trial credentials.  Example :      GET : /api/ai-account/orgs/main/free-trial/ .  Response:     {         is_in_free_trial: true     }

        :param org: (required)
        :type org: str
        :param user_id: (required)
        :type user_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ai_account_orgs_users_free_trial_list_serialize(
            org=org,
            user_id=user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Credential]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ai_account_orgs_users_free_trial_list_serialize(
        self,
        org,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if org is not None:
            _path_params['org'] = org
        if user_id is not None:
            _path_params['user_id'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'PlatformApiKeyAuthentication'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ai-account/orgs/{org}/users/{user_id}/free-trial',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


